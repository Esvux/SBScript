  options {
    IGNORE_CASE = true;
    STATIC = false;
  }

  PARSER_BEGIN(ParserLenguaje)
  package org.esvux.sbscript.parser;

  import org.esvux.sbscript.ast.Nodo;
  import org.esvux.sbscript.ast.FabricaNodos;
  import org.esvux.sbscript.ast.Constantes;

  public class ParserLenguaje {

    private void reportarError(String errorString){
      System.err.println(errorString);
    }

    public static void main(String args[]) throws ParseException {
      ParserLenguaje parser = new ParserLenguaje(
        new java.io.StringReader("Num a,b,c;")
      );
      parser.PROGRAMA();
      System.out.println("Análisis concluido!!");
    }

  }
  PARSER_END(ParserLenguaje)

  void PROGRAMA():{}
  {
    (
      LOOKAHEAD(2)
      DEC_GLOBAL()
    |
      METODO()
    |
      PRINCIPAL()
    )+
  }

  void DEC_GLOBAL():{}
  {
    TIPO_VAR() <ID> ("," <ID>)* [ "=" EXP() ] <PYC>
  }

  void TIPO_VAR():{}
  {
    <T_NUM> | <T_STR> | <T_BOOL>    
  }

  void METODO():{}
  {
    TIPO_MET() <ID> "(" [ TIPO_VAR() <ID> ( "," TIPO_VAR() <ID> )* ] ")"
    "{" SENTENCIAS() "}"
  }

  void TIPO_MET():{}
  {
    <T_NUM> | <T_STR> | <T_BOOL> | <T_VOID>
  }

  void PRINCIPAL():{}
  {
    <PR_PRINCIPAL> "(" ")"
    "{" SENTENCIAS() "}"
  }

  void CUERPO():{}
  {
    "{" SENTENCIAS() "}" 
  }

  void SENTENCIAS():{}
  {
    try{
      ( LOOKAHEAD(2)
        ASIGNACION() <PYC>
      |
        LLAMADA() <PYC>
      |
        DEC_LOCAL() <PYC>
      |
        RETORNO() <PYC>
      |
        MOSTRAR() <PYC>
      |
        SI()
      |
        SELECCIONA()
      |
        MIENTRAS()
      |
        PARA()
      )
     } catch (ParseException e) {
      Token t;
      do {
        t = getNextToken();
      } while (t.kind != PYC);
      reportarError(e.getMessage());
    }
  }

  void DEC_LOCAL():{}
  {
    TIPO_VAR() <ID> ("," <ID>)* [ "=" EXP() ]
  }

  void ASIGNACION():{}
  {
    <ID> "=" EXP()
  }

  void LLAMADA():{}
  {
    <ID> "(" [ EXP() ( "," EXP() )* ] ")"
  }

  void RETORNO():{}
  {
    <PR_RETORNO> EXP()
  }

  void MOSTRAR():{}
  {
    <PR_MOSTRAR> "(" EXP() ( "," EXP() )* ")"
  }

  void SI():{}
  {
    <PR_SI> "(" EXP() ")" CUERPO() [ <PR_SINO> CUERPO() ]
  }

  void SELECCIONA():{}
  {
    <PR_SELECCIONA> "(" EXP() ")" 
      ( NATIVO() ":" CUERPO() )+
  }

  void MIENTRAS():{}
  {
    <PR_MIENTRAS> "(" EXP() ")" CUERPO()
  }

  void PARA():{}
  {
    <PR_PARA> "(" <T_NUM> <ID> "=" EXP() <PYC> EXP() <PYC> ( <INCREMENTO> | <DECREMENTO> ) ")" CUERPO()
  }

  //--------------------------------------
  //     EXPRESIONES
  //--------------------------------------
  Nodo EXP():{ Nodo nodo; }
  {
    nodo=LOG_OR()
    { return nodo; }
  }

  //--------------------------------------
  //     Expresiones lógicas
  //--------------------------------------
  Nodo LOG_OR():{ Nodo nodo, temp, extra; }
  {
    nodo=LOG_AND() 
      ( 
        "||" extra=LOG_AND() 
          {
            temp = FabricaNodos.copiar(nodo);
            nodo = FabricaNodos.creaLogica(Constantes.OP_OR, nodo, extra);
          }
      )*
    { return nodo; }
  }

  Nodo LOG_AND():{ Nodo nodo, temp, extra; }
  {
    nodo=LOG_XOR() 
      ( 
        "&&" extra=LOG_XOR() 
          {
            temp = FabricaNodos.copiar(nodo);
            nodo = FabricaNodos.creaLogica(Constantes.OP_AND, nodo, extra);
          }
      )*
    { return nodo; }
  }

  Nodo LOG_XOR():{ Nodo nodo, temp, extra; }
  {
    nodo=LOG_NOT() 
      ( 
        "¿?" extra=LOG_NOT() 
          {
            temp = FabricaNodos.copiar(nodo);
            nodo = FabricaNodos.creaLogica(Constantes.OP_XOR, nodo, extra);
          }
      )*
    { return nodo; }
  }

  Nodo LOG_NOT():{ Nodo nodo, extra; }
  {
    ( 
      nodo=RELACIONAL()
    |
      "!" extra=LOG_NOT()
      { nodo = FabricaNodos.creaNot(extra); }
    )
    { return nodo; }
  }

  //--------------------------------------
  //     Expresiones relacionales
  //--------------------------------------
  Nodo RELACIONAL():{ String op; Nodo nodo, temp, extra; }
  {
    nodo=ARITM() 
    [ 
      op=OP_REL() extra=ARITM() 
      { 
        temp = FabricaNodos.copiar(nodo); 
        nodo = FabricaNodos.creaRelacional(op, temp, extra);
      }
    ]
    { return nodo; }
  }

  String OP_REL():{ String op; }
  {
    ( 
      "==" { op = Constantes.OP_EQU;}
    | 
      "!=" { op = Constantes.OP_NEQ;}
    | 
      ">"  { op = Constantes.OP_MAY;}
    | 
      ">=" { op = Constantes.OP_MYE;}
    | 
      "<"  { op = Constantes.OP_MEN;}
    | 
      "<=" { op = Constantes.OP_MNE;}
    )
    { return op; }
  }

  //--------------------------------------
  //     Expresiones aritméticas
  //--------------------------------------
  Nodo ARITM():{ Nodo nodo, temp, extra; }
  {
    nodo=TERM()
      ( 
        "+" extra=TERM()
          {
            temp = FabricaNodos.copiar(nodo);
            nodo = FabricaNodos.creaAritmetica(Constantes.OP_SUM, temp, extra);
          }
      |
        "-" extra=TERM()
          {
            temp = FabricaNodos.copiar(nodo);
            nodo = FabricaNodos.creaAritmetica(Constantes.OP_RES, temp, extra);
          }
      )*
    { return nodo; }
  }

  Nodo TERM():{ Nodo nodo, temp, extra; }
  {
    nodo=FACT()
      (
        "*" extra=FACT()
          {
            temp = FabricaNodos.copiar(nodo);
            nodo = FabricaNodos.creaAritmetica(Constantes.OP_MUL, temp, extra);
          }
      |
        "/" extra=FACT()
          {
            temp = FabricaNodos.copiar(nodo);
            nodo = FabricaNodos.creaAritmetica(Constantes.OP_DIV, temp, extra);
          }
      |
        "%" extra=FACT()
          {
            temp = FabricaNodos.copiar(nodo);
            nodo = FabricaNodos.creaAritmetica(Constantes.OP_MOD, temp, extra);
          }
      )*
    { return nodo; }
  }

  Nodo FACT():{ Nodo nodo, temp, extra; }
  {
    nodo=VAL()
      ( 
        "^" extra=VAL() 
          {
            temp = FabricaNodos.copiar(nodo);
            nodo = FabricaNodos.creaAritmetica(Constantes.OP_POT, temp, extra);
          }
      )*
    { return nodo; }
  }

  Nodo VAL():{ Nodo nodo, temp; Token token; }
  {
    (
      "(" nodo=EXP() ")"
    |
      "-" temp=VAL()
      { nodo = FabricaNodos.creaMenosUnario(temp); }
    |
      token=<ID> 
        { nodo = FabricaNodos.creaAccesoID(token.image); } 
      [ "(" { nodo.setRol(Constantes.LLAMADA); } 
        [ temp=EXP() { nodo.addHijo(temp); } 
          ( "," temp=EXP() { nodo.addHijo(temp); } )* ] ")" ]
    |
      nodo=NATIVO()
    )
    { return nodo; }
  }

  Nodo NATIVO():{ Nodo nodo; Token token; }
  {
    ( 
      token=<NUMERO> 
      { nodo = FabricaNodos.creaNumero(token.image); }
    | 
      token=<CADENA> 
      { nodo = FabricaNodos.creaCadena(token.image); }
    | 
      <TRUE> 
      { nodo = FabricaNodos.creaTrue(); }
    | 
      <FALSE>
      { nodo = FabricaNodos.creaFalse(); }
    )
    { return nodo; }
  }
    
  //--------------------------------------
  //     Definición de reglas léxicas
  //--------------------------------------
  TOKEN:{
      < PYC : ";" >
    | < T_NUM : "Num" >
    | < T_STR : "Str" >
    | < T_BOOL : "Bool" >
    | < T_VOID : "Void" >
    | < PR_PRINCIPAL : "Principal" >
    | < PR_MOSTRAR : "Mostrar" >
    | < PR_RETORNO : "Retorno" >
    | < PR_SI : "Si" >
    | < PR_SINO : "Sino" >
    | < PR_SELECCIONA : "Selecciona" >
    | < PR_MIENTRAS : "Mientras" >
    | < PR_PARA : "Para" >
    | < DECREMENTO : "--" >
    | < INCREMENTO : "++" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < NUMERO  : (["0"-"9"])+ | (["0"-"9"])+ "." (["0"-"9"])+ >
    | < CADENA  : "\"" ( (~["\"","\\","\n","\r"]) | ("\\" ["n","t","v","b","r","f","a","\\","?","'","\""] ) )* "\"">
    | < ID : ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9","_"])*>
  }

  //--------------------------------------
  //           Tokens ignorados
  //--------------------------------------
  SKIP: { " " | "\n" | "\t" | "\r" }

  //--------------------------------------
  //       Definición de comentarios
  //--------------------------------------
  MORE :
  {
    "//" : IN_SINGLE_LINE_COMMENT
  |
    <"/*" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
  |
    "*/" : IN_MULTI_LINE_COMMENT
  }

  <IN_SINGLE_LINE_COMMENT>
  SPECIAL_TOKEN :
  {
    <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
  }

  <IN_FORMAL_COMMENT>
  SPECIAL_TOKEN :
  {
    <FORMAL_COMMENT: "*/" > : DEFAULT
  }

  <IN_MULTI_LINE_COMMENT>
  SPECIAL_TOKEN :
  {
    <MULTI_LINE_COMMENT: "*/" > : DEFAULT
  }

  <IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
  MORE :
  {
    < ~[] >
  }
